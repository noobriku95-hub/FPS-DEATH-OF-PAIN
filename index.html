<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS DEATH OF PAIN - Multijoueur</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
            transition: all 0.2s;
        }
        #crosshair.aiming {
            width: 2px;
            height: 2px;
            background: red;
        }
        #sniper-scope {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 9;
        }
        #sniper-scope.active {
            display: block;
        }
        #sniper-scope::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background: black;
            box-shadow: 0 0 2px rgba(255,255,255,0.5);
        }
        #sniper-scope::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            background: black;
            box-shadow: 0 0 2px rgba(255,255,255,0.5);
        }
        .scope-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid black;
            border-radius: 50%;
            box-shadow: 0 0 0 2000px rgba(0,0,0,0.7), inset 0 0 20px rgba(0,0,0,0.3);
        }
        .scope-circle-outer {
            width: 80vh;
            height: 80vh;
        }
        .scope-circle-inner {
            width: 8vh;
            height: 8vh;
        }
        .scope-tick {
            position: absolute;
            background: black;
            box-shadow: 0 0 1px rgba(255,255,255,0.5);
        }
        .scope-tick-h {
            height: 2px;
            width: 20px;
        }
        .scope-tick-v {
            width: 2px;
            height: 20px;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px black;
            z-index: 10;
        }
        #weapon-name {
            color: #ffaa00;
            font-weight: bold;
            font-size: 24px;
            margin-bottom: 5px;
        }
        #best-score-display {
            color: #ffd700;
            font-weight: bold;
            margin-top: 10px;
        }
        #multiplayer-info {
            color: #00ff00;
            font-weight: bold;
            margin-top: 10px;
            font-size: 16px;
        }
        #health-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(255, 0, 0, 0.3);
            border: 3px solid white;
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666);
            transition: width 0.3s;
        }
        .damage-number {
            position: absolute;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black, 0 0 10px black;
            pointer-events: none;
            z-index: 15;
            animation: floatUp 1s ease-out forwards;
        }
        .damage-number.headshot {
            color: #ff0000;
            font-size: 32px;
            text-shadow: 2px 2px 4px black, 0 0 15px #ff0000;
        }
        .damage-number.critical {
            color: #ffff00;
            font-size: 36px;
        }
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 1;
            }
            50% {
                transform: translateY(-30px) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateY(-80px) scale(0.8);
                opacity: 0;
            }
        }
        #connection-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 25;
            border: 3px solid #00ff00;
            max-width: 500px;
        }
        #connection-modal input {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            margin: 10px 0;
            border: 2px solid #00ff00;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            box-sizing: border-box;
        }
        #username-input {
            border: 2px solid #ffaa00 !important;
            font-size: 18px !important;
            font-weight: bold;
            text-align: center;
        }
        #connection-modal button {
            padding: 15px 30px;
            font-size: 18px;
            background: #00ff00;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px 5px;
        }
        #connection-modal button:hover {
            background: #00cc00;
        }
        #connection-modal button.secondary {
            background: #ff8800;
        }
        #connection-modal button.secondary:hover {
            background: #ff6600;
        }
        #connection-modal.hidden {
            display: none;
        }
        #my-peer-id {
            background: rgba(0, 255, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 18px;
            word-break: break-all;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
        }
        #instructions.hidden {
            display: none;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(255, 0, 0, 0.8);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            display: none;
        }
        #game-over button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        #game-over button:hover {
            background: #45a049;
        }
        .new-record {
            color: #ffd700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffd700;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        #audio-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="connection-modal">
        <h2>üéÆ FPS DEATH OF PAIN</h2>
        <input type="text" id="username-input" placeholder="Entre ton pseudo..." maxlength="12" value="Joueur">
        <p style="font-size: 14px; color: #aaa;">Mode Multijoueur P2P</p>
        
        <div id="mode-select">
            <button onclick="startHosting()">üè† H√©berger une Partie</button>
            <button onclick="showJoinForm()" class="secondary">üîó Rejoindre une Partie</button>
            <button onclick="playOffline()">üéØ Jouer Solo (IA)</button>
        </div>

        <div id="hosting-info" style="display:none;">
            <h3>Votre ID de Partie:</h3>
            <div id="my-peer-id">Connexion...</div>
            <p style="font-size: 14px; color: #aaa;">Partagez cet ID avec votre ami!</p>
            <p id="waiting-status" style="color: #ffaa00;">‚è≥ En attente d'un joueur...</p>
        </div>

        <div id="join-form" style="display:none;">
            <h3>Rejoindre une Partie</h3>
            <input type="text" id="peer-id-input" placeholder="Entrez l'ID de votre ami">
            <br>
            <button onclick="connectToPeer()">Se Connecter</button>
            <button onclick="showModeSelect()" class="secondary">Retour</button>
        </div>

        <p id="connection-status" style="margin-top: 15px; color: #ffaa00; min-height: 20px;"></p>
    </div>

    <div id="crosshair"></div>
    <div id="sniper-scope">
        <div class="scope-circle scope-circle-outer"></div>
        <div class="scope-circle scope-circle-inner"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; left: calc(50% - 100px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; left: calc(50% - 80px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; left: calc(50% - 60px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; left: calc(50% - 40px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; left: calc(50% - 20px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; right: calc(50% - 100px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; right: calc(50% - 80px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; right: calc(50% - 60px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; right: calc(50% - 40px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-h" style="top: 50%; right: calc(50% - 20px); transform: translateY(-50%);"></div>
        <div class="scope-tick scope-tick-v" style="left: 50%; top: calc(50% + 20px); transform: translateX(-50%);"></div>
        <div class="scope-tick scope-tick-v" style="left: 50%; top: calc(50% + 40px); transform: translateX(-50%);"></div>
        <div class="scope-tick scope-tick-v" style="left: 50%; top: calc(50% + 60px); transform: translateX(-50%);"></div>
        <div class="scope-tick scope-tick-v" style="left: 50%; top: calc(50% + 80px); transform: translateX(-50%);"></div>
    </div>
    
    <div id="hud">
        <div id="weapon-name">Pistolet</div>
        <div>Munitions: <span id="ammo">30</span> / <span id="reserve">90</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Ennemis: <span id="enemies">5</span></div>
        <div id="best-score-display">üèÜ Record: <span id="best-score">0</span></div>
        <div id="multiplayer-info">‚ö° Mode: <span id="game-mode">Solo</span> | Joueurs: <span id="player-count">1</span></div>
    </div>
    
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>
    
    <button id="audio-toggle">üîä Son: ON</button>
    
    <div id="instructions">
        <h2>FPS DEATH OF PAIN</h2>
        <p>ZQSD ou WASD - D√©placement<br>
        Souris - Regarder<br>
        Clic gauche - Tirer<br>
        Clic droit - Viser<br>
        Espace - Sauter<br>
        R - Recharger<br>
        1, 2, 3 - Changer d'arme</p>
        <p><strong>Sniper = One Shot Headshot!</strong></p>
        <p id="record-message" style="color: #ffd700; margin-top: 15px;"></p>
        <p><em>Cliquez pour commencer</em></p>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <p style="font-size: 22px;">Score: <span id="final-score">0</span></p>
        <p id="best-score-message" style="font-size: 18px; margin-top: 10px;"></p>
        <p id="new-record-message" style="display: none;"></p>
        <button onclick="location.reload()">Rejouer</button>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let peer = null;
        let conn = null;
        let isMultiplayer = false;
        let isHost = false;
        const otherPlayers = {};
        let myPlayerId = null;
        let myUsername = 'Joueur';

        window.showModeSelect = function() {
            document.getElementById('mode-select').style.display = 'block';
            document.getElementById('hosting-info').style.display = 'none';
            document.getElementById('join-form').style.display = 'none';
            document.getElementById('connection-status').textContent = '';
        };

        window.showJoinForm = function() {
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('join-form').style.display = 'block';
        };

        window.playOffline = function() {
            myUsername = document.getElementById('username-input').value.trim() || 'Joueur';
            isMultiplayer = false;
            document.getElementById('connection-modal').classList.add('hidden');
            document.getElementById('game-mode').textContent = 'Solo (IA)';
            initGame();
        };

        window.startHosting = function() {
            myUsername = document.getElementById('username-input').value.trim() || 'Joueur';
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('hosting-info').style.display = 'block';
            document.getElementById('connection-status').textContent = 'üîÑ Cr√©ation...';

            peer = new Peer({
                config: {
                    'iceServers': [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:global.stun.twilio.com:3478' }
                    ]
                }
            });

            peer.on('open', (id) => {
                myPlayerId = id;
                isHost = true;
                document.getElementById('my-peer-id').textContent = id;
                document.getElementById('connection-status').textContent = '‚úÖ Partie cr√©√©e!';
            });

            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(connection);
                document.getElementById('waiting-status').textContent = '‚úÖ Connect√©!';
                
                setTimeout(() => {
                    isMultiplayer = true;
                    document.getElementById('connection-modal').classList.add('hidden');
                    document.getElementById('game-mode').textContent = 'Multijoueur';
                    document.getElementById('player-count').textContent = '2';
                    initGame();
                    sendToOpponent({ type: 'username', username: myUsername });
                }, 1000);
            });

            peer.on('error', (err) => {
                document.getElementById('connection-status').textContent = '‚ùå Erreur: ' + err.type;
            });
        };

        window.connectToPeer = function() {
            myUsername = document.getElementById('username-input').value.trim() || 'Joueur';
            const remotePeerId = document.getElementById('peer-id-input').value.trim();
            
            if (!remotePeerId) {
                document.getElementById('connection-status').textContent = '‚ùå Entrez un ID!';
                return;
            }

            document.getElementById('connection-status').textContent = 'üîÑ Connexion...';

            peer = new Peer({
                config: {
                    'iceServers': [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:global.stun.twilio.com:3478' }
                    ]
                }
            });

            peer.on('open', (id) => {
                myPlayerId = id;
                conn = peer.connect(remotePeerId, { reliable: true });
                setupConnection(conn);
                
                setTimeout(() => {
                    if (conn && conn.open) {
                        isMultiplayer = true;
                        isHost = false;
                        document.getElementById('connection-modal').classList.add('hidden');
                        document.getElementById('game-mode').textContent = 'Multijoueur';
                        document.getElementById('player-count').textContent = '2';
                        initGame();
                        sendToOpponent({ type: 'username', username: myUsername });
                    } else {
                        document.getElementById('connection-status').textContent = '‚ùå √âchec connexion!';
                    }
                }, 2000);
            });

            peer.on('error', (err) => {
                document.getElementById('connection-status').textContent = '‚ùå Erreur: ' + err.type;
            });
        };

        function setupConnection(connection) {
            connection.on('open', () => {
                document.getElementById('connection-status').textContent = '‚úÖ Connect√©!';
            });

            connection.on('data', (data) => {
                handleMultiplayerData(data);
            });

            connection.on('close', () => {
                if (isMultiplayer) {
                    alert('Adversaire d√©connect√©!');
                    location.reload();
                }
            });
        }

        function sendToOpponent(data) {
            if (conn && conn.open) {
                try {
                    conn.send(data);
                } catch (e) {
                    console.error('Erreur envoi:', e);
                }
            }
        }

        function handleMultiplayerData(data) {
            if (!data || !data.type) return;

            switch (data.type) {
                case 'username':
                    if (otherPlayers['opponent']) {
                        updatePlayerName(otherPlayers['opponent'], data.username);
                    }
                    break;

                case 'position':
                    if (otherPlayers['opponent']) {
                        otherPlayers['opponent'].targetPosition = new THREE.Vector3(data.x, data.y, data.z);
                        otherPlayers['opponent'].targetRotation = data.rotation;
                    } else {
                        addOtherPlayer({ 
                            id: 'opponent', 
                            x: data.x, 
                            y: data.y, 
                            z: data.z,
                            username: data.username || 'Adversaire'
                        });
                    }
                    break;

                case 'shoot':
                    playSound('enemyShoot');
                    createOtherPlayerBullet(data);
                    break;

                case 'hit':
                    if (data.targetId === 'me') {
                        takeDamage(data.damage);
                    }
                    break;

                case 'weapon':
                    if (otherPlayers['opponent']) {
                        const colors = [0xff0000, 0x8B4513, 0x1a1a1a];
                        otherPlayers['opponent'].children[0].material.color.setHex(colors[data.weapon] || 0xff0000);
                    }
                    break;
            }
        }

        function addOtherPlayer(playerInfo) {
            const playerGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 8, 3),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            body.position.y = 4;
            body.castShadow = true;
            body.userData.hitbox = 'body';
            playerGroup.add(body);
            
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(3, 3, 3),
                new THREE.MeshStandardMaterial({ color: 0xcc0000 })
            );
            head.position.y = 10;
            head.castShadow = true;
            head.userData.hitbox = 'head';
            playerGroup.add(head);

            const enemyWeapon = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 4),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            enemyWeapon.position.set(2.5, 5, 0);
            enemyWeapon.castShadow = true;
            playerGroup.add(enemyWeapon);
            
            const nameTag = createNameTag(playerInfo.username || 'Adversaire');
            nameTag.position.y = 13;
            playerGroup.add(nameTag);
            
            playerGroup.position.set(playerInfo.x, playerInfo.y, playerInfo.z);
            playerGroup.targetPosition = new THREE.Vector3(playerInfo.x, playerInfo.y, playerInfo.z);
            playerGroup.targetRotation = 0;
            playerGroup.health = 100;
            playerGroup.userData.isPlayer = true;
            
            scene.add(playerGroup);
            otherPlayers['opponent'] = playerGroup;
        }

        function createNameTag(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 512, 128);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(4, 1, 1);
            return sprite;
        }

        function updatePlayerName(player, username) {
            const oldNameTag = player.children.find(child => child.type === 'Sprite');
            if (oldNameTag) {
                player.remove(oldNameTag);
            }
            
            const newNameTag = createNameTag(username);
            newNameTag.position.y = 13;
            player.add(newNameTag);
        }

        function createOtherPlayerBullet(data) {
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff8800 })
            );
            
            bullet.position.set(data.position.x, data.position.y, data.position.z);
            bullet.velocity = new THREE.Vector3(data.direction.x, data.direction.y, data.direction.z);
            bullet.damage = data.damage || 34;
            bullet.isMultiplayerBullet = true;
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let score = 0;
        let bestScore = 0;
        let health = 100;
        let isReloading = false;
        let isAiming = false;
        const bullets = [];
        const enemies = [];
        const enemyBullets = [];
        const raycaster = new THREE.Raycaster();
        const bulletRaycaster = new THREE.Raycaster();
        const collidableObjects = [];
        
        let weapon;
        let weaponBob = 0;
        let weaponRecoil = 0;
        let currentWeaponIndex = 0;

        const HEADSHOT_MULTIPLIER = 2.0;
        const SNIPER_HEADSHOT_KILL = true;

        const weapons = [
            {
                name: 'Pistolet',
                ammo: 30,
                maxAmmo: 30,
                reserve: 90,
                damage: 34,
                fireRate: 200,
                reloadTime: 1500,
                bulletSpeed: 500,
                spread: 0.01,
                bulletsPerShot: 1,
                color: 0x333333
            },
            {
                name: 'Fusil √† Pompe',
                ammo: 8,
                maxAmmo: 8,
                reserve: 32,
                damage: 25,
                fireRate: 800,
                reloadTime: 2000,
                bulletSpeed: 400,
                spread: 0.1,
                bulletsPerShot: 8,
                color: 0x8B4513
            },
            {
                name: 'Sniper',
                ammo: 5,
                maxAmmo: 5,
                reserve: 20,
                damage: 100,
                fireRate: 1200,
                reloadTime: 2500,
                bulletSpeed: 800,
                spread: 0,
                bulletsPerShot: 1,
                color: 0x1a1a1a
            }
        ];

        let lastShotTime = 0;
        let lastEmit = 0;

        let audioListener;
        let audioEnabled = true;
        let audioContext;
        let backgroundMusicSource = null;
        let lastFootstep = 0;

        const PLAYER_HEIGHT = 10;
        const BEST_SCORE_KEY = 'fps3d_best_score';
        const BASE_FOV = 75;
        const AIM_FOV = 50;

        function initGame() {
            loadBestScore();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 750);

            camera = new THREE.PerspectiveCamera(BASE_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            audioListener = new THREE.AudioListener();
            camera.add(audioListener);
            audioContext = audioListener.context;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.receiveShadow = true;
            scene.add(floor);

            createWalls();
            createWeapon();
            if (!isMultiplayer) {
                createEnemies();
            }
            updateWeaponUI();

            controls = new PointerLockControls(camera, document.body);
            
            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => controls.lock());

            controls.addEventListener('lock', () => {
                instructions.classList.add('hidden');
                if (audioEnabled && !backgroundMusicSource) {
                    playBackgroundMusic();
                }
            });

            controls.addEventListener('unlock', () => {
                instructions.classList.remove('hidden');
            });

            scene.add(controls.object);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            document.getElementById('audio-toggle').addEventListener('click', toggleAudio);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        function showDamageNumber(damage, position, isHeadshot = false, isCritical = false) {
            const screenPos = position.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;

            const damageEl = document.createElement('div');
            damageEl.className = 'damage-number';
            if (isHeadshot) damageEl.classList.add('headshot');
            if (isCritical) damageEl.classList.add('critical');
            
            damageEl.textContent = Math.round(damage);
            if (isHeadshot) damageEl.textContent = 'üíÄ ' + damageEl.textContent;
            if (isCritical) damageEl.textContent += ' CRITICAL!';
            
            damageEl.style.left = x + 'px';
            damageEl.style.top = y + 'px';
            
            document.body.appendChild(damageEl);
            
            setTimeout(() => {
                damageEl.remove();
            }, 1000);
        }

        function loadBestScore() {
            const saved = localStorage.getItem(BEST_SCORE_KEY);
            if (saved !== null) {
                bestScore = parseInt(saved);
                document.getElementById('best-score').textContent = bestScore;
                
                if (bestScore > 0) {
                    document.getElementById('record-message').textContent = 
                        `Record √† battre: ${bestScore} points!`;
                }
            }
        }

        function saveBestScore() {
            localStorage.setItem(BEST_SCORE_KEY, bestScore.toString());
        }

        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = score;
            
            if (score > bestScore) {
                bestScore = score;
                document.getElementById('best-score').textContent = bestScore;
                saveBestScore();
            }
        }

        function updateWeaponUI() {
            const currentWeapon = weapons[currentWeaponIndex];
            document.getElementById('weapon-name').textContent = currentWeapon.name;
            document.getElementById('ammo').textContent = currentWeapon.ammo;
            document.getElementById('reserve').textContent = currentWeapon.reserve;
        }

        function switchWeapon(index) {
            if (index === currentWeaponIndex || isReloading) return;
            if (index < 0 || index >= weapons.length) return;
            
            if (isAiming && currentWeaponIndex === 2) {
                document.getElementById('sniper-scope').classList.remove('active');
            }
            
            currentWeaponIndex = index;
            const currentWeapon = weapons[currentWeaponIndex];
            
            weapon.children[0].material.color.setHex(currentWeapon.color);
            
            updateWeaponUI();
            playSound('reload');
            
            if (isMultiplayer) {
                sendToOpponent({ type: 'weapon', weapon: currentWeaponIndex });
            }
        }

        function playBackgroundMusic() {
            if (!audioEnabled || !audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.value = 220;
            osc.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.value = 0.05;
            osc.start();
            backgroundMusicSource = osc;
        }

        function playSound(type) {
            if (!audioEnabled || !audioContext) return;

            try {
                if (type === 'shoot') {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    const freq = currentWeaponIndex === 1 ? 400 : (currentWeaponIndex === 2 ? 1000 : 800);
                    osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.1);
                } else if (type === 'reload') {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, audioContext.currentTime);
                    osc.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.3);
                } else if (type === 'hit') {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, audioContext.currentTime);
                    gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.15);
                } else if (type === 'damage') {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.2);
                } else if (type === 'enemyShoot') {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.12);
                    gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.12);
                } else if (type === 'footstep') {
                    const bufferSize = audioContext.sampleRate * 0.1;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    const noise = audioContext.createBufferSource();
                    noise.buffer = buffer;
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 300;
                    const gain = audioContext.createGain();
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);
                    gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    noise.start(audioContext.currentTime);
                    noise.stop(audioContext.currentTime + 0.1);
                } else if (type === 'bulletImpact') {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.08);
                    gain.gain.setValueAtTime(0.25, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                    osc.start(audioContext.currentTime);
                    osc.stop(audioContext.currentTime + 0.08);
                }
            } catch(e) {
                console.log('Audio error:', e);
            }
        }

        function toggleAudio() {
            audioEnabled = !audioEnabled;
            const btn = document.getElementById('audio-toggle');
            btn.textContent = audioEnabled ? 'üîä Son: ON' : 'üîá Son: OFF';
            
            if (!audioEnabled && backgroundMusicSource) {
                backgroundMusicSource.stop();
                backgroundMusicSource = null;
            } else if (audioEnabled && controls.isLocked && !backgroundMusicSource) {
                playBackgroundMusic();
            }
        }

        function createWeapon() {
            weapon = new THREE.Group();

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.2, 0.6),
                new THREE.MeshStandardMaterial({ color: weapons[0].color, metalness: 0.8, roughness: 0.2 })
            );
            weapon.add(body);

            const grip = new THREE.Mesh(
                new THREE.BoxGeometry(0.12, 0.3, 0.15),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
            );
            grip.position.set(0, -0.2, -0.15);
            weapon.add(grip);

            const barrel = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.03, 0.4, 16),
                new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 1, roughness: 0.1 })
            );
            barrel.rotation.z = Math.PI / 2;
            barrel.position.set(0, 0.05, 0.4);
            weapon.add(barrel);

            const sight = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.08, 0.04),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            sight.position.set(0, 0.14, 0.1);
            weapon.add(sight);

            weapon.position.set(0.3, -0.3, -0.5);
            weapon.rotation.y = -0.1;
            
            camera.add(weapon);
        }

        function createWalls() {
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            
            const wallData = [
                { x: 0, z: -200, w: 400, d: 10 },
                { x: -200, z: 0, w: 10, d: 400 },
                { x: 200, z: 0, w: 10, d: 400 }
            ];

            wallData.forEach(pos => {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(pos.w, 40, pos.d),
                    wallMaterial
                );
                wall.position.set(pos.x, 20, pos.z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                collidableObjects.push(wall);
            });

            for (let i = 0; i < 8; i++) {
                const obstacle = new THREE.Mesh(
                    new THREE.BoxGeometry(20, 30, 20),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                );
                obstacle.position.set(
                    Math.random() * 300 - 150,
                    15,
                    Math.random() * 300 - 150
                );
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
                collidableObjects.push(obstacle);
            }
        }

        function createEnemies() {
            for (let i = 0; i < 5; i++) {
                const enemyGroup = new THREE.Group();
                
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 8, 3),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                body.position.y = 4;
                body.castShadow = true;
                body.userData.hitbox = 'body';
                enemyGroup.add(body);

                const head = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 3, 3),
                    new THREE.MeshStandardMaterial({ color: 0xcc0000 })
                );
                head.position.y = 10;
                head.castShadow = true;
                head.userData.hitbox = 'head';
                enemyGroup.add(head);

                const enemyWeapon = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.5, 4),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                enemyWeapon.position.set(2.5, 5, 0);
                enemyWeapon.castShadow = true;
                enemyGroup.add(enemyWeapon);

                enemyGroup.position.set(
                    Math.random() * 300 - 150,
                    0,
                    Math.random() * -150 - 50
                );

                enemyGroup.health = 100;
                enemyGroup.lastShot = Date.now();
                enemyGroup.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    0,
                    (Math.random() - 0.5) * 2
                );
                enemyGroup.changeDirectionTimer = Math.random() * 3000 + 2000;
                enemyGroup.lastDirectionChange = Date.now();
                enemyGroup.userData.isEnemy = true;

                scene.add(enemyGroup);
                enemies.push(enemyGroup);
            }
            updateEnemyCount();
        }

        function updateEnemyCount() {
            document.getElementById('enemies').textContent = enemies.length;
        }

        function checkCollision(position) {
            const playerRadius = 5;
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1)
            ];

            for (let dir of directions) {
                raycaster.set(position, dir);
                const intersects = raycaster.intersectObjects(collidableObjects);
                
                if (intersects.length > 0 && intersects[0].distance < playerRadius) {
                    return true;
                }
            }
            return false;
        }

        function checkBulletCollision(bullet, delta) {
            const moveVector = bullet.velocity.clone().multiplyScalar(delta);
            const moveDistance = moveVector.length();
            const moveDirection = moveVector.normalize();

            bulletRaycaster.set(bullet.position, moveDirection);
            const wallIntersects = bulletRaycaster.intersectObjects(collidableObjects);
            
            if (wallIntersects.length > 0 && wallIntersects[0].distance < moveDistance + 1) {
                createImpactEffect(wallIntersects[0].point);
                playSound('bulletImpact');
                return true;
            }

            return false;
        }

        function createImpactEffect(position) {
            const impact = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 })
            );
            impact.position.copy(position);
            scene.add(impact);

            let startTime = Date.now();
            const duration = 400;
            
            function animateImpact() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    scene.remove(impact);
                    impact.geometry.dispose();
                    impact.material.dispose();
                    return;
                }
                
                impact.material.opacity = 0.8 * (1 - progress);
                impact.scale.setScalar(1 + progress * 2);
                requestAnimationFrame(animateImpact);
            }
            
            animateImpact();
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                case 'KeyZ':
                case 'ArrowUp':
                    moveForward = true;
                    break;
                case 'KeyA':
                case 'KeyQ':
                case 'ArrowLeft':
                    moveLeft = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump === true) velocity.y += 150;
                    canJump = false;
                    break;
                case 'KeyR':
                    reload();
                    break;
                case 'Digit1':
                    switchWeapon(0);
                    break;
                case 'Digit2':
                    switchWeapon(1);
                    break;
                case 'Digit3':
                    switchWeapon(2);
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                case 'KeyZ':
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 'KeyA':
                case 'KeyQ':
                case 'ArrowLeft':
                    moveLeft = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = false;
                    break;
            }
        }

        function onMouseDown(event) {
            if (event.button === 0 && controls.isLocked === true && !isReloading) {
                shoot();
            } else if (event.button === 2 && controls.isLocked === true) {
                startAiming();
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                stopAiming();
            }
        }

        function startAiming() {
            isAiming = true;
            
            if (currentWeaponIndex === 2) {
                document.getElementById('sniper-scope').classList.add('active');
                document.getElementById('crosshair').style.display = 'none';
            } else {
                document.getElementById('crosshair').classList.add('aiming');
            }
            
            const startFov = camera.fov;
            const targetFov = AIM_FOV;
            const duration = 200;
            const startTime = Date.now();
            
            function animateZoom() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                camera.fov = startFov + (targetFov - startFov) * progress;
                camera.updateProjectionMatrix();
                
                if (progress < 1 && isAiming) {
                    requestAnimationFrame(animateZoom);
                }
            }
            
            animateZoom();
        }

        function stopAiming() {
            isAiming = false;
            document.getElementById('sniper-scope').classList.remove('active');
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('crosshair').classList.remove('aiming');
            
            const startFov = camera.fov;
            const targetFov = BASE_FOV;
            const duration = 200;
            const startTime = Date.now();
            
            function animateZoom() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                camera.fov = startFov + (targetFov - startFov) * progress;
                camera.updateProjectionMatrix();
                
                if (progress < 1 && !isAiming) {
                    requestAnimationFrame(animateZoom);
                }
            }
            
            animateZoom();
        }

        function shoot() {
            const currentWeapon = weapons[currentWeaponIndex];
            const now = Date.now();
            
            if (currentWeapon.ammo <= 0 || now - lastShotTime < currentWeapon.fireRate) return;
            
            lastShotTime = now;
            currentWeapon.ammo--;
            updateWeaponUI();

            playSound('shoot');
            weaponRecoil = isAiming ? 0.05 : 0.1;

            const flash = new THREE.PointLight(0xffff00, 2, 10);
            flash.position.copy(camera.position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);

            const shootDirection = new THREE.Vector3();
            camera.getWorldDirection(shootDirection);

            for (let i = 0; i < currentWeapon.bulletsPerShot; i++) {
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                
                bullet.position.copy(camera.position);
                bullet.velocity = new THREE.Vector3();
                camera.getWorldDirection(bullet.velocity);
                
                const spread = isAiming ? currentWeapon.spread * 0.3 : currentWeapon.spread;
                bullet.velocity.x += (Math.random() - 0.5) * spread;
                bullet.velocity.y += (Math.random() - 0.5) * spread;
                bullet.velocity.z += (Math.random() - 0.5) * spread;
                bullet.velocity.normalize();
                
                bullet.velocity.multiplyScalar(currentWeapon.bulletSpeed);
                bullet.damage = currentWeapon.damage;
                bullet.weaponType = currentWeaponIndex;
                
                scene.add(bullet);
                bullets.push(bullet);
            }

            if (isMultiplayer) {
                sendToOpponent({
                    type: 'shoot',
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    direction: {
                        x: shootDirection.x * currentWeapon.bulletSpeed,
                        y: shootDirection.y * currentWeapon.bulletSpeed,
                        z: shootDirection.z * currentWeapon.bulletSpeed
                    },
                    weapon: currentWeaponIndex,
                    damage: currentWeapon.damage
                });
            }

            if (currentWeapon.ammo === 0) {
                reload();
            }
        }

        function reload() {
            const currentWeapon = weapons[currentWeaponIndex];
            
            if (!isReloading && currentWeapon.ammo < currentWeapon.maxAmmo && currentWeapon.reserve > 0) {
                isReloading = true;
                playSound('reload');
                
                animateReload();
                
                setTimeout(() => {
                    const neededAmmo = currentWeapon.maxAmmo - currentWeapon.ammo;
                    const ammoToReload = Math.min(neededAmmo, currentWeapon.reserve);
                    
                    currentWeapon.ammo += ammoToReload;
                    currentWeapon.reserve -= ammoToReload;
                    
                    updateWeaponUI();
                    isReloading = false;
                }, currentWeapon.reloadTime);
            }
        }

        function animateReload() {
            const reloadDuration = weapons[currentWeaponIndex].reloadTime;
            const startTime = Date.now();
            
            const originalPos = {
                x: weapon.position.x,
                y: weapon.position.y,
                z: weapon.position.z
            };
            
            const originalRot = {
                x: weapon.rotation.x,
                y: weapon.rotation.y,
                z: weapon.rotation.z
            };
            
            function animateReloadFrame() {
                if (!isReloading) return;
                
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / reloadDuration, 1);
                
                if (progress < 0.3) {
                    const phase1 = progress / 0.3;
                    weapon.position.y = originalPos.y - 0.4 * phase1;
                    weapon.rotation.z = originalRot.z - 0.3 * phase1;
                }
                else if (progress < 0.5) {
                    const phase2 = (progress - 0.3) / 0.2;
                    weapon.position.y = originalPos.y - 0.4 - 0.2 * phase2;
                    
                    if (phase2 < 0.5 && !weapon.magazineDropped) {
                        createFallingMagazine();
                        weapon.magazineDropped = true;
                    }
                }
                else if (progress < 0.8) {
                    const phase3 = (progress - 0.5) / 0.3;
                    weapon.position.y = originalPos.y - 0.6 + 0.4 * phase3;
                }
                else {
                    const phase4 = (progress - 0.8) / 0.2;
                    weapon.position.y = originalPos.y - 0.2 + 0.2 * phase4;
                    weapon.rotation.z = originalRot.z - 0.3 + 0.3 * phase4;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animateReloadFrame);
                } else {
                    weapon.position.set(originalPos.x, originalPos.y, originalPos.z);
                    weapon.rotation.set(originalRot.x, originalRot.y, originalRot.z);
                    weapon.magazineDropped = false;
                }
            }
            
            animateReloadFrame();
        }

        function createFallingMagazine() {
            const magazineGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.04);
            const magazineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.7,
                roughness: 0.3
            });
            const magazine = new THREE.Mesh(magazineGeometry, magazineMaterial);
            
            magazine.position.copy(camera.position);
            magazine.position.y -= 0.5;
            magazine.position.z -= 0.3;
            
            magazine.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                -5,
                (Math.random() - 0.5) * 2
            );
            
            magazine.rotationVelocity = {
                x: (Math.random() - 0.5) * 5,
                y: (Math.random() - 0.5) * 5,
                z: (Math.random() - 0.5) * 5
            };
            
            scene.add(magazine);
            
            const startTime = Date.now();
            function animateMagazineFall() {
                const elapsed = (Date.now() - startTime) / 1000;
                
                if (elapsed > 2) {
                    scene.remove(magazine);
                    magazine.geometry.dispose();
                    magazine.material.dispose();
                    return;
                }
                
                const delta = 0.016;
                
                magazine.velocity.y -= 9.8 * delta;
                
                magazine.position.x += magazine.velocity.x * delta;
                magazine.position.y += magazine.velocity.y * delta;
                magazine.position.z += magazine.velocity.z * delta;
                
                magazine.rotation.x += magazine.rotationVelocity.x * delta;
                magazine.rotation.y += magazine.rotationVelocity.y * delta;
                magazine.rotation.z += magazine.rotationVelocity.z * delta;
                
                if (magazine.position.y < 0.5) {
                    magazine.position.y = 0.5;
                    magazine.velocity.y *= -0.4;
                    magazine.velocity.x *= 0.8;
                    magazine.velocity.z *= 0.8;
                }
                
                requestAnimationFrame(animateMagazineFall);
            }
            
            animateMagazineFall();
        }

        function enemyShoot(enemy) {
            const now = Date.now();
            if (now - enemy.lastShot < 2000) return;
            enemy.lastShot = now;

            playSound('enemyShoot');

            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            
            bullet.position.copy(enemy.position);
            bullet.position.y += 5;
            
            const targetPosition = new THREE.Vector3(
                controls.object.position.x,
                controls.object.position.y - 2,
                controls.object.position.z
            );
            
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, bullet.position).normalize();
            
            const inaccuracy = 0.05;
            direction.x += (Math.random() - 0.5) * inaccuracy;
            direction.y += (Math.random() - 0.5) * inaccuracy;
            direction.z += (Math.random() - 0.5) * inaccuracy;
            direction.normalize();
            
            bullet.velocity = direction.multiplyScalar(200);
            
            scene.add(bullet);
            enemyBullets.push(bullet);
        }

        function updateEnemies(delta) {
            if (!isMultiplayer) {
                enemies.forEach(enemy => {
                    const now = Date.now();
                    
                    if (now - enemy.lastDirectionChange > enemy.changeDirectionTimer) {
                        enemy.velocity.x = (Math.random() - 0.5) * 30;
                        enemy.velocity.z = (Math.random() - 0.5) * 30;
                        enemy.lastDirectionChange = now;
                        enemy.changeDirectionTimer = Math.random() * 3000 + 2000;
                    }

                    const oldPos = enemy.position.clone();
                    enemy.position.x += enemy.velocity.x * delta;
                    enemy.position.z += enemy.velocity.z * delta;

                    const enemyBox = new THREE.Box3().setFromObject(enemy);
                    let collision = false;
                    
                    for (let obj of collidableObjects) {
                        const objBox = new THREE.Box3().setFromObject(obj);
                        if (enemyBox.intersectsBox(objBox)) {
                            collision = true;
                            break;
                        }
                    }

                    if (collision || Math.abs(enemy.position.x) > 180 || Math.abs(enemy.position.z) > 180) {
                        enemy.position.copy(oldPos);
                        enemy.velocity.x *= -1;
                        enemy.velocity.z *= -1;
                    }

                    enemy.lookAt(controls.object.position.x, enemy.position.y, controls.object.position.z);

                    const distanceToPlayer = enemy.position.distanceTo(controls.object.position);
                    if (distanceToPlayer < 100 && Math.random() > 0.97) {
                        enemyShoot(enemy);
                    }
                });
            }
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (!bullets[i]) continue;

                if (checkBulletCollision(bullets[i], delta)) {
                    scene.remove(bullets[i]);
                    bullets[i].geometry.dispose();
                    bullets[i].material.dispose();
                    bullets.splice(i, 1);
                    continue;
                }

                bullets[i].position.add(bullets[i].velocity.clone().multiplyScalar(delta));
                
                let hitTarget = false;
                
                // Collision avec ennemis IA
                if (!isMultiplayer && !bullets[i].isMultiplayerBullet) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const distToEnemy = bullets[i].position.distanceTo(enemy.position);
                        
                        if (distToEnemy < 5) {
                            for (let part of enemy.children) {
                                if (!part.geometry) continue;
                                
                                const partWorldPos = new THREE.Vector3();
                                part.getWorldPosition(partWorldPos);
                                const distToPart = bullets[i].position.distanceTo(partWorldPos);
                                
                                if (distToPart < 3) {
                                    const isHeadshot = part.userData.hitbox === 'head';
                                    let damage = bullets[i].damage;
                                    let isCritical = false;
                                    
                                    if (isHeadshot) {
                                        if (bullets[i].weaponType === 2 && SNIPER_HEADSHOT_KILL) {
                                            damage = enemy.health;
                                            isCritical = true;
                                        } else {
                                            damage *= HEADSHOT_MULTIPLIER;
                                        }
                                    }
                                    
                                    enemy.health -= damage;
                                    playSound('hit');
                                    showDamageNumber(damage, partWorldPos, isHeadshot, isCritical);
                                    
                                    part.material.color.setHex(0xffffff);
                                    setTimeout(() => {
                                        if (part && part.material) {
                                            part.material.color.setHex(isHeadshot ? 0xcc0000 : 0xff0000);
                                        }
                                    }, 100);

                                    if (enemy.health <= 0) {
                                        scene.remove(enemy);
                                        enemies.splice(j, 1);
                                        updateScore(isHeadshot ? 200 : 100);
                                        updateEnemyCount();

                                        if (enemies.length < 3) {
                                            setTimeout(() => createEnemies(), 3000);
                                        }
                                    }
                                    
                                    hitTarget = true;
                                    break;
                                }
                            }
                            
                            if (hitTarget) break;
                        }
                    }
                }
                
                // Collision avec joueurs en multijoueur
                if (isMultiplayer && otherPlayers['opponent'] && !bullets[i].isMultiplayerBullet) {
                    const player = otherPlayers['opponent'];
                    const distToPlayer = bullets[i].position.distanceTo(player.position);
                    
                    if (distToPlayer < 5) {
                        for (let part of player.children) {
                            if (!part.geometry || part.type === 'Sprite') continue;
                            
                            const partWorldPos = new THREE.Vector3();
                            part.getWorldPosition(partWorldPos);
                            const distToPart = bullets[i].position.distanceTo(partWorldPos);
                            
                            if (distToPart < 3) {
                                const isHeadshot = part.userData.hitbox === 'head';
                                let damage = bullets[i].damage;
                                
                                if (isHeadshot) {
                                    if (bullets[i].weaponType === 2 && SNIPER_HEADSHOT_KILL) {
                                        damage = 100;
                                    } else {
                                        damage *= HEADSHOT_MULTIPLIER;
                                    }
                                }
                                
                                playSound('hit');
                                showDamageNumber(damage, partWorldPos, isHeadshot);
                                
                                sendToOpponent({
                                    type: 'hit',
                                    targetId: 'me',
                                    damage: damage
                                });
                                
                                hitTarget = true;
                                break;
                            }
                        }
                    }
                }
                
                if (hitTarget) {
                    scene.remove(bullets[i]);
                    bullets[i].geometry.dispose();
                    bullets[i].material.dispose();
                    bullets.splice(i, 1);
                    continue;
                }
                
                if (bullets[i] && bullets[i].position.length() > 500) {
                    scene.remove(bullets[i]);
                    bullets[i].geometry.dispose();
                    bullets[i].material.dispose();
                    bullets.splice(i, 1);
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (checkBulletCollision(enemyBullets[i], delta)) {
                    scene.remove(enemyBullets[i]);
                    enemyBullets[i].geometry.dispose();
                    enemyBullets[i].material.dispose();
                    enemyBullets.splice(i, 1);
                    continue;
                }

                enemyBullets[i].position.add(enemyBullets[i].velocity.clone().multiplyScalar(delta));
                
                const distanceToPlayer = enemyBullets[i].position.distanceTo(controls.object.position);
                if (distanceToPlayer < 4) {
                    takeDamage(10);
                    scene.remove(enemyBullets[i]);
                    enemyBullets[i].geometry.dispose();
                    enemyBullets[i].material.dispose();
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                if (enemyBullets[i].position.length() > 500) {
                    scene.remove(enemyBullets[i]);
                    enemyBullets[i].geometry.dispose();
                    enemyBullets[i].material.dispose();
                    enemyBullets.splice(i, 1);
                }
            }
        }

        function takeDamage(amount) {
            health -= amount;
            if (health < 0) health = 0;
            
            playSound('damage');
            
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = health + '%';

            document.body.style.background = 'rgba(255, 0, 0, 0.3)';
            setTimeout(() => {
                document.body.style.background = '';
            }, 200);

            if (health <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            controls.unlock();
            
            document.getElementById('final-score').textContent = score;
            
            const previousBest = parseInt(localStorage.getItem(BEST_SCORE_KEY)) || 0;
            const isNewRecord = score > previousBest;
            
            if (isNewRecord && score > 0) {
                const newRecordMsg = document.getElementById('new-record-message');
                newRecordMsg.innerHTML = '<p class="new-record">üéâ NOUVEAU RECORD! üéâ</p>';
                newRecordMsg.style.display = 'block';
                
                document.getElementById('best-score-message').textContent = 
                    `Ancien record: ${previousBest} points`;
                
                localStorage.setItem(BEST_SCORE_KEY, score.toString());
                bestScore = score;
            } else {
                document.getElementById('best-score-message').textContent = 
                    `Meilleur score: ${bestScore} points`;
                
                if (score < bestScore) {
                    const diff = bestScore - score;
                    document.getElementById('best-score-message').innerHTML += 
                        `<br><small style="color: #ffcccc;">Encore ${diff} points!</small>`;
                }
            }
            
            document.getElementById('game-over').style.display = 'block';
            
            if (backgroundMusicSource) {
                backgroundMusicSource.stop();
                backgroundMusicSource = null;
            }
        }

        function updateWeaponAnimation(delta) {
            if (moveForward || moveBackward || moveLeft || moveRight) {
                weaponBob += delta * 10;
                weapon.position.y = -0.3 + Math.sin(weaponBob) * 0.02;
                weapon.position.x = 0.3 + Math.cos(weaponBob * 0.5) * 0.01;
                
                const now = Date.now();
                if (now - lastFootstep > 500) {
                    playSound('footstep');
                    lastFootstep = now;
                }
            }

            if (weaponRecoil > 0) {
                weapon.position.z = -0.5 + weaponRecoil;
                weapon.rotation.x = weaponRecoil * 0.5;
                weaponRecoil -= delta * 2;
            } else {
                weapon.position.z = -0.5;
                weapon.rotation.x = 0;
                weaponRecoil = 0;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked === true && health > 0) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 50.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                const oldPosition = controls.object.position.clone();

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                if (checkCollision(controls.object.position)) {
                    controls.object.position.copy(oldPosition);
                }

                controls.object.position.y += velocity.y * delta;

                if (controls.object.position.y < PLAYER_HEIGHT) {
                    velocity.y = 0;
                    controls.object.position.y = PLAYER_HEIGHT;
                    canJump = true;
                }

                if (isMultiplayer && Date.now() - lastEmit > 50) {
                    sendToOpponent({
                        type: 'position',
                        x: controls.object.position.x,
                        y: controls.object.position.y,
                        z: controls.object.position.z,
                        rotation: controls.object.rotation.y,
                        username: myUsername
                    });
                    lastEmit = Date.now();
                }

                if (otherPlayers['opponent']) {
                    const player = otherPlayers['opponent'];
                    if (player.targetPosition) {
                        player.position.lerp(player.targetPosition, 0.2);
                        if (player.targetRotation !== undefined) {
                            player.rotation.y += (player.targetRotation - player.rotation.y) * 0.2;
                        }
                    }
                }

                updateEnemies(delta);
                updateBullets(delta);
                updateWeaponAnimation(delta);

                prevTime = time;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
