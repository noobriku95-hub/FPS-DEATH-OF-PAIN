<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS DEATH OF PAIN</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
            transition: all 0.2s;
        }
        #crosshair.aiming {
            width: 2px;
            height: 2px;
            background: red;
        }
        #sniper-scope {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 9;
        }
        #sniper-scope.active {
            display: block;
        }
        #sniper-scope::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background: black;
        }
        #sniper-scope::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            background: black;
        }
        .scope-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid black;
            border-radius: 50%;
            box-shadow: 0 0 0 2000px rgba(0,0,0,0.7);
        }
        .scope-circle-outer {
            width: 80vh;
            height: 80vh;
        }
        .scope-circle-inner {
            width: 8vh;
            height: 8vh;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px black;
            z-index: 10;
        }
        #weapon-name {
            color: #ffaa00;
            font-weight: bold;
            font-size: 24px;
        }
        #multiplayer-info {
            color: #00ff00;
            font-weight: bold;
            margin-top: 10px;
            font-size: 16px;
        }
        #health-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(255, 0, 0, 0.3);
            border: 3px solid white;
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666);
            transition: width 0.3s;
        }
        .damage-number {
            position: absolute;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            z-index: 15;
            animation: floatUp 1s ease-out forwards;
        }
        .damage-number.headshot {
            color: #ff0000;
            font-size: 32px;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-80px); opacity: 0; }
        }
        #connection-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 25;
            border: 3px solid #00ff00;
            max-width: 500px;
        }
        #connection-modal input {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            margin: 10px 0;
            border: 2px solid #00ff00;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            box-sizing: border-box;
        }
        #username-input {
            border: 2px solid #ffaa00 !important;
            font-weight: bold;
        }
        #connection-modal button {
            padding: 15px 30px;
            font-size: 18px;
            background: #00ff00;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px 5px;
        }
        #connection-modal button:hover {
            background: #00cc00;
        }
        #connection-modal button.secondary {
            background: #ff8800;
        }
        #connection-modal.hidden {
            display: none;
        }
        #my-peer-id {
            background: rgba(0, 255, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 16px;
            word-break: break-all;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
        }
        #instructions.hidden {
            display: none;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(255, 0, 0, 0.8);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            display: none;
        }
        #game-over button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="connection-modal">
        <h2>üéÆ FPS DEATH OF PAIN</h2>
        <input type="text" id="username-input" placeholder="Ton pseudo" maxlength="12" value="Joueur">
        
        <div id="mode-select">
            <button onclick="startHosting()">üè† H√©berger</button>
            <button onclick="showJoinForm()" class="secondary">üîó Rejoindre</button>
            <button onclick="playOffline()">üéØ Solo</button>
        </div>

        <div id="hosting-info" style="display:none;">
            <h3>ID de Partie:</h3>
            <div id="my-peer-id">Connexion...</div>
            <p id="waiting-status" style="color: #ffaa00;">‚è≥ Attente...</p>
        </div>

        <div id="join-form" style="display:none;">
            <h3>Rejoindre</h3>
            <input type="text" id="peer-id-input" placeholder="ID de ton ami">
            <br>
            <button onclick="connectToPeer()">Connecter</button>
            <button onclick="showModeSelect()" class="secondary">Retour</button>
        </div>

        <p id="connection-status" style="margin-top: 15px; color: #ffaa00;"></p>
    </div>

    <div id="crosshair"></div>
    <div id="sniper-scope">
        <div class="scope-circle scope-circle-outer"></div>
        <div class="scope-circle scope-circle-inner"></div>
    </div>
    
    <div id="hud">
        <div id="weapon-name">Pistolet</div>
        <div>Munitions: <span id="ammo">30</span> / <span id="reserve">90</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Ennemis: <span id="enemies">5</span></div>
        <div id="multiplayer-info">Mode: <span id="game-mode">Solo</span> | Joueurs: <span id="player-count">1</span></div>
    </div>
    
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>
    
    <div id="instructions">
        <h2>FPS DEATH OF PAIN</h2>
        <p>ZQSD - D√©placement<br>
        Souris - Regarder<br>
        Clic gauche - Tirer<br>
        Clic droit - Viser<br>
        Espace - Sauter<br>
        R - Recharger<br>
        1, 2, 3 - Armes</p>
        <p><em>Cliquez pour jouer</em></p>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">Rejouer</button>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let peer = null;
        let conn = null;
        let isMultiplayer = false;
        const otherPlayers = {};
        let myUsername = 'Joueur';

        window.showModeSelect = function() {
            document.getElementById('mode-select').style.display = 'block';
            document.getElementById('hosting-info').style.display = 'none';
            document.getElementById('join-form').style.display = 'none';
        };

        window.showJoinForm = function() {
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('join-form').style.display = 'block';
        };

        window.playOffline = function() {
            myUsername = document.getElementById('username-input').value || 'Joueur';
            document.getElementById('connection-modal').classList.add('hidden');
            document.getElementById('game-mode').textContent = 'Solo';
            initGame();
        };

        window.startHosting = function() {
            myUsername = document.getElementById('username-input').value || 'Joueur';
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('hosting-info').style.display = 'block';

            peer = new Peer();

            peer.on('open', (id) => {
                document.getElementById('my-peer-id').textContent = id;
                document.getElementById('connection-status').textContent = '‚úÖ Pr√™t!';
            });

            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(connection);
                
                setTimeout(() => {
                    isMultiplayer = true;
                    document.getElementById('connection-modal').classList.add('hidden');
                    document.getElementById('game-mode').textContent = 'Multi';
                    document.getElementById('player-count').textContent = '2';
                    initGame();
                    sendData({ type: 'username', username: myUsername });
                }, 1000);
            });
        };

        window.connectToPeer = function() {
            myUsername = document.getElementById('username-input').value || 'Joueur';
            const remotePeerId = document.getElementById('peer-id-input').value.trim();
            
            if (!remotePeerId) return;

            peer = new Peer();

            peer.on('open', () => {
                conn = peer.connect(remotePeerId);
                setupConnection(conn);
                
                setTimeout(() => {
                    if (conn && conn.open) {
                        isMultiplayer = true;
                        document.getElementById('connection-modal').classList.add('hidden');
                        document.getElementById('game-mode').textContent = 'Multi';
                        document.getElementById('player-count').textContent = '2';
                        initGame();
                        sendData({ type: 'username', username: myUsername });
                    }
                }, 2000);
            });
        };

        function setupConnection(connection) {
            connection.on('open', () => {
                console.log('Connect√©!');
            });

            connection.on('data', handleData);
        }

        function sendData(data) {
            if (conn && conn.open) {
                conn.send(data);
            }
        }

        function handleData(data) {
            if (!data) return;

            if (data.type === 'position' && otherPlayers['opponent']) {
                otherPlayers['opponent'].targetPos = new THREE.Vector3(data.x, data.y, data.z);
            } else if (data.type === 'position') {
                addOtherPlayer(data);
            } else if (data.type === 'shoot') {
                createBullet(data);
            } else if (data.type === 'hit') {
                takeDamage(data.damage);
            }
        }

        function addOtherPlayer(data) {
            const group = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 8, 3),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            body.position.y = 4;
            body.userData.hitbox = 'body';
            group.add(body);
            
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(3, 3, 3),
                new THREE.MeshStandardMaterial({ color: 0xcc0000 })
            );
            head.position.y = 10;
            head.userData.hitbox = 'head';
            group.add(head);

            const weapon = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 4),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            weapon.position.set(2.5, 5, 0);
            group.add(weapon);
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(data.username || 'Adversaire', 128, 38);
            
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(4, 1, 1);
            sprite.position.y = 13;
            group.add(sprite);
            
            group.position.set(data.x, data.y, data.z);
            group.targetPos = new THREE.Vector3(data.x, data.y, data.z);
            group.userData.isPlayer = true;
            
            scene.add(group);
            otherPlayers['opponent'] = group;
        }

        function createBullet(data) {
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff8800 })
            );
            
            bullet.position.set(data.x, data.y, data.z);
            bullet.velocity = new THREE.Vector3(data.vx, data.vy, data.vz);
            bullet.isEnemy = true;
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let score = 0;
        let health = 100;
        let isReloading = false;
        let isAiming = false;
        const bullets = [];
        const enemies = [];
        const collidableObjects = [];
        
        let weapon;
        let weaponRecoil = 0;
        let currentWeaponIndex = 0;
        let lastEmit = 0;

        const weapons = [
            { name: 'Pistolet', ammo: 30, maxAmmo: 30, reserve: 90, damage: 34, fireRate: 200, reloadTime: 1500, bulletSpeed: 500, spread: 0.01, bulletsPerShot: 1, color: 0x333333 },
            { name: 'Fusil √† Pompe', ammo: 8, maxAmmo: 8, reserve: 32, damage: 25, fireRate: 800, reloadTime: 2000, bulletSpeed: 400, spread: 0.1, bulletsPerShot: 8, color: 0x8B4513 },
            { name: 'Sniper', ammo: 5, maxAmmo: 5, reserve: 20, damage: 100, fireRate: 1200, reloadTime: 2500, bulletSpeed: 800, spread: 0, bulletsPerShot: 1, color: 0x1a1a1a }
        ];

        let lastShotTime = 0;
        const PLAYER_HEIGHT = 10;
        const BASE_FOV = 75;
        const AIM_FOV = 50;

        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(BASE_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000),
                new THREE.MeshStandardMaterial({ color: 0x228B22 })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            createWalls();
            createWeapon();
            if (!isMultiplayer) createEnemies();
            updateUI();

            controls = new PointerLockControls(camera, document.body);
            
            document.getElementById('instructions').addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => document.getElementById('instructions').classList.add('hidden'));
            controls.addEventListener('unlock', () => document.getElementById('instructions').classList.remove('hidden'));

            scene.add(controls.object);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', e => e.preventDefault());

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
        }

        function createWeapon() {
            weapon = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.2, 0.6),
                new THREE.MeshStandardMaterial({ color: weapons[0].color })
            );
            weapon.add(body);
            weapon.position.set(0.3, -0.3, -0.5);
            camera.add(weapon);
        }

        function createWalls() {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
            
            [[0, -200, 400, 10], [-200, 0, 10, 400], [200, 0, 10, 400]].forEach(([x, z, w, d]) => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w, 40, d), wallMat);
                wall.position.set(x, 20, z);
                scene.add(wall);
                collidableObjects.push(wall);
            });
        }

        function createEnemies() {
            for (let i = 0; i < 5; i++) {
                const group = new THREE.Group();
                
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 8, 3),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                body.position.y = 4;
                body.userData.hitbox = 'body';
                group.add(body);

                const head = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 3, 3),
                    new THREE.MeshStandardMaterial({ color: 0xcc0000 })
                );
                head.position.y = 10;
                head.userData.hitbox = 'head';
                group.add(head);

                group.position.set(
                    Math.random() * 300 - 150,
                    0,
                    Math.random() * -100 - 50
                );

                group.health = 100;
                group.velocity = new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2);

                scene.add(group);
                enemies.push(group);
            }
            document.getElementById('enemies').textContent = enemies.length;
        }

        function updateUI() {
            const w = weapons[currentWeaponIndex];
            document.getElementById('weapon-name').textContent = w.name;
            document.getElementById('ammo').textContent = w.ammo;
            document.getElementById('reserve').textContent = w.reserve;
        }

        function showDamage(dmg, pos, isHead) {
            const screenPos = pos.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;

            const el = document.createElement('div');
            el.className = 'damage-number' + (isHead ? ' headshot' : '');
            el.textContent = (isHead ? 'üíÄ ' : '') + Math.round(dmg);
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function onKeyDown(e) {
            if (e.code === 'KeyW' || e.code === 'KeyZ') moveForward = true;
            if (e.code === 'KeyA' || e.code === 'KeyQ') moveLeft = true;
            if (e.code === 'KeyS') moveBackward = true;
            if (e.code === 'KeyD') moveRight = true;
            if (e.code === 'Space' && canJump) { velocity.y += 150; canJump = false; }
            if (e.code === 'KeyR') reload();
            if (e.code === 'Digit1') switchWeapon(0);
            if (e.code === 'Digit2') switchWeapon(1);
            if (e.code === 'Digit3') switchWeapon(2);
        }

        function onKeyUp(e) {
            if (e.code === 'KeyW' || e.code === 'KeyZ') moveForward = false;
            if (e.code === 'KeyA' || e.code === 'KeyQ') moveLeft = false;
            if (e.code === 'KeyS') moveBackward = false;
            if (e.code === 'KeyD') moveRight = false;
        }

        function onMouseDown(e) {
            if (e.button === 0 && controls.isLocked && !isReloading) shoot();
            if (e.button === 2 && controls.isLocked) startAiming();
        }

        function onMouseUp(e) {
            if (e.button === 2) stopAiming();
        }

        function startAiming() {
            isAiming = true;
            if (currentWeaponIndex === 2) {
                document.getElementById('sniper-scope').classList.add('active');
                document.getElementById('crosshair').style.display = 'none';
            } else {
                document.getElementById('crosshair').classList.add('aiming');
            }
            animateFOV(camera.fov, AIM_FOV);
        }

        function stopAiming() {
            isAiming = false;
            document.getElementById('sniper-scope').classList.remove('active');
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('crosshair').classList.remove('aiming');
            animateFOV(camera.fov, BASE_FOV);
        }

        function animateFOV(start, target) {
            const startTime = Date.now();
            function anim() {
                const progress = Math.min((Date.now() - startTime) / 200, 1);
                camera.fov = start + (target - start) * progress;
                camera.updateProjectionMatrix();
                if (progress < 1) requestAnimationFrame(anim);
            }
            anim();
        }

        function switchWeapon(idx) {
            if (idx === currentWeaponIndex || isReloading) return;
            currentWeaponIndex = idx;
            weapon.children[0].material.color.setHex(weapons[idx].color);
            updateUI();
        }

        function shoot() {
            const w = weapons[currentWeaponIndex];
            if (w.ammo <= 0 || Date.now() - lastShotTime < w.fireRate) return;
            
            lastShotTime = Date.now();
            w.ammo--;
            updateUI();
            weaponRecoil = 0.1;

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            for (let i = 0; i < w.bulletsPerShot; i++) {
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                
                bullet.position.copy(camera.position);
                const v = dir.clone();
                v.x += (Math.random()-0.5) * w.spread;
                v.y += (Math.random()-0.5) * w.spread;
                v.z += (Math.random()-0.5) * w.spread;
                v.normalize().multiplyScalar(w.bulletSpeed);
                
                bullet.velocity = v;
                bullet.damage = w.damage;
                bullet.weaponType = currentWeaponIndex;
                
                scene.add(bullet);
                bullets.push(bullet);
            }

            if (isMultiplayer) {
                sendData({
                    type: 'shoot',
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z,
                    vx: dir.x * w.bulletSpeed,
                    vy: dir.y * w.bulletSpeed,
                    vz: dir.z * w.bulletSpeed
                });
            }

            if (w.ammo === 0) reload();
        }

        function reload() {
            const w = weapons[currentWeaponIndex];
            if (isReloading || w.ammo >= w.maxAmmo || w.reserve <= 0) return;
            
            isReloading = true;
            setTimeout(() => {
                const need = w.maxAmmo - w.ammo;
                const add = Math.min(need, w.reserve);
                w.ammo += add;
                w.reserve -= add;
                updateUI();
                isReloading = false;
            }, w.reloadTime);
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].position.add(bullets[i].velocity.clone().multiplyScalar(delta));
                
                let hit = false;
                
                if (!bullets[i].isEnemy) {
                    const targets = isMultiplayer && otherPlayers['opponent'] 
                        ? [otherPlayers['opponent']] 
                        : enemies;
                    
                    for (let j = targets.length - 1; j >= 0; j--) {
                        const target = targets[j];
                        const dist = bullets[i].position.distanceTo(target.position);
                        
                        if (dist < 5) {
                            for (let part of target.children) {
                                if (!part.geometry || part.type === 'Sprite') continue;
                                
                                const partPos = new THREE.Vector3();
                                part.getWorldPosition(partPos);
                                const partDist = bullets[i].position.distanceTo(partPos);
                                
                                if (partDist < 3) {
                                    const isHead = part.userData.hitbox === 'head';
                                    let dmg = bullets[i].damage;
                                    
                                    if (isHead) {
                                        dmg = bullets[i].weaponType === 2 ? 200 : dmg * 2;
                                    }
                                    
                                    showDamage(dmg, partPos, isHead);
                                    
                                    if (isMultiplayer) {
                                        sendData({ type: 'hit', damage: dmg });
                                    } else {
                                        target.health -= dmg;
                                        if (target.health <= 0) {
                                            scene.remove(target);
                                            enemies.splice(j, 1);
                                            score += isHead ? 200 : 100;
                                            document.getElementById('score').textContent = score;
                                            document.getElementById('enemies').textContent = enemies.length;
                                        }
                                    }
                                    
                                    hit = true;
                                    break;
                                }
                            }
                            if (hit) break;
                        }
                    }
                }
                
                if (hit || bullets[i].position.length() > 500) {
                    scene.remove(bullets[i]);
                    bullets.splice(i, 1);
                }
            }
        }

        function takeDamage(dmg) {
            health -= dmg;
            if (health < 0) health = 0;
            document.getElementById('health-fill').style.width = health + '%';

            if (health <= 0) {
                controls.unlock();
                document.getElementById('final-score').textContent = score;
                document.getElementById('game-over').style.display = 'block';
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked && health > 0) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10 * delta;
                velocity.z -= velocity.z * 10 * delta;
                velocity.y -= 9.8 * 50 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.object.position.y += velocity.y * delta;

                if (controls.object.position.y < PLAYER_HEIGHT) {
                    velocity.y = 0;
                    controls.object.position.y = PLAYER_HEIGHT;
                    canJump = true;
                }

                if (isMultiplayer && Date.now() - lastEmit > 50) {
                    sendData({
                        type: 'position',
                        x: controls.object.position.x,
                        y: controls.object.position.y,
                        z: controls.object.position.z,
                        username: myUsername
                    });
                    lastEmit = Date.now();
                }

                if (otherPlayers['opponent']?.targetPos) {
                    otherPlayers['opponent'].position.lerp(otherPlayers['opponent'].targetPos, 0.2);
                }

                enemies.forEach(e => {
                    e.position.x += e.velocity.x * delta * 15;
                    e.position.z += e.velocity.z * delta * 15;
                    e.lookAt(controls.object.position);
                });

                updateBullets(delta);

                if (weaponRecoil > 0) {
                    weapon.position.z = -0.5 + weaponRecoil;
                    weaponRecoil -= delta * 2;
                } else {
                    weapon.position.z = -0.5;
                }

                prevTime = time;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
