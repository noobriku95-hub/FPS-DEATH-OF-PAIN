<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS DEATH OF PAIN</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: white; border: 2px solid black;
            border-radius: 50%; pointer-events: none; z-index: 10; transition: all 0.2s;
        }
        #crosshair.aiming { width: 2px; height: 2px; background: red; }
        #sniper-scope {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; pointer-events: none; z-index: 9;
        }
        #sniper-scope.active { display: block; }
        #sniper-scope::before {
            content: ''; position: absolute; top: 50%; left: 0;
            width: 100%; height: 2px; background: black;
        }
        #sniper-scope::after {
            content: ''; position: absolute; left: 50%; top: 0;
            width: 2px; height: 100%; background: black;
        }
        .scope-circle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            border: 3px solid black; border-radius: 50%;
            box-shadow: 0 0 0 2000px rgba(0,0,0,0.7);
        }
        .scope-circle-outer { width: 80vh; height: 80vh; }
        .scope-circle-inner { width: 8vh; height: 8vh; }
        #hud {
            position: absolute; top: 20px; left: 20px; color: white;
            font-size: 20px; text-shadow: 2px 2px 4px black; z-index: 10;
        }
        #weapon-name { color: #ffaa00; font-weight: bold; font-size: 24px; margin-bottom: 5px; }
        #multiplayer-info { color: #00ff00; font-weight: bold; margin-top: 10px; font-size: 16px; }
        #health-bar {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 30px; background: rgba(255, 0, 0, 0.3);
            border: 3px solid white; border-radius: 5px; overflow: hidden; z-index: 10;
        }
        #health-fill {
            height: 100%; width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666); transition: width 0.3s;
        }
        .damage-number {
            position: absolute; color: white; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 4px black; pointer-events: none; z-index: 15;
            animation: floatUp 1s ease-out forwards;
        }
        .damage-number.headshot { color: #ff0000; font-size: 32px; }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-80px); opacity: 0; }
        }
        #connection-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0, 0, 0, 0.9); padding: 40px;
            border-radius: 10px; text-align: center; z-index: 25;
            border: 3px solid #00ff00; max-width: 500px;
        }
        #connection-modal input {
            width: 100%; padding: 15px; font-size: 16px; margin: 10px 0;
            border: 2px solid #00ff00; background: rgba(0, 0, 0, 0.7);
            color: white; border-radius: 5px; box-sizing: border-box;
        }
        #username-input {
            border: 2px solid #ffaa00 !important;
            font-size: 18px !important; font-weight: bold; text-align: center;
        }
        #connection-modal button {
            padding: 15px 30px; font-size: 18px; background: #00ff00;
            color: black; border: none; border-radius: 5px;
            cursor: pointer; font-weight: bold; margin: 10px 5px;
        }
        #connection-modal button:hover { background: #00cc00; }
        #connection-modal button.secondary { background: #ff8800; }
        #connection-modal.hidden { display: none; }
        #my-peer-id {
            background: rgba(0, 255, 0, 0.2); padding: 10px; border-radius: 5px;
            margin: 10px 0; font-family: monospace; font-size: 18px; word-break: break-all;
        }
        #instructions {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0, 0, 0, 0.8); padding: 30px;
            border-radius: 10px; text-align: center; z-index: 20;
        }
        #instructions.hidden { display: none; }
        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(255, 0, 0, 0.8); padding: 40px;
            border-radius: 10px; text-align: center; z-index: 20; display: none;
        }
        #game-over button {
            margin-top: 20px; padding: 15px 30px; font-size: 18px;
            background: #4CAF50; color: white; border: none;
            border-radius: 5px; cursor: pointer; font-weight: bold;
        }
        #match-timer {
            color: #00ff00; font-size: 28px; font-weight: bold; margin-top: 10px;
            text-shadow: 0 0 10px #00ff00; transition: transform 0.2s;
        }
        #match-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0, 0, 0, 0.95); padding: 50px;
            border-radius: 10px; text-align: center; z-index: 30;
            border: 5px solid #ffd700; display: none;
        }
        #match-over h2 {
            font-size: 48px; margin: 0 0 20px 0; text-shadow: 0 0 20px currentColor;
        }
        #match-over button {
            margin-top: 30px; padding: 20px 40px; font-size: 24px;
            background: #4CAF50; color: white; border: none;
            border-radius: 5px; cursor: pointer; font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="connection-modal">
        <h2>FPS DEATH OF PAIN</h2>
        <input type="text" id="username-input" placeholder="Ton pseudo" maxlength="12" value="Joueur">
        
        <div id="mode-select">
            <button onclick="startHosting()">Heberger</button>
            <button onclick="showJoinForm()" class="secondary">Rejoindre</button>
            <button onclick="playOffline()">Solo</button>
        </div>

        <div id="hosting-info" style="display:none;">
            <h3>ID de Partie:</h3>
            <div id="my-peer-id">Connexion...</div>
            <p id="waiting-status" style="color: #ffaa00;">Attente...</p>
        </div>

        <div id="join-form" style="display:none;">
            <h3>Rejoindre</h3>
            <input type="text" id="peer-id-input" placeholder="ID de ton ami">
            <br>
            <button onclick="connectToPeer()">Connecter</button>
            <button onclick="showModeSelect()" class="secondary">Retour</button>
        </div>

        <p id="connection-status" style="margin-top: 15px; color: #ffaa00;"></p>
    </div>

    <div id="crosshair"></div>
    <div id="sniper-scope">
        <div class="scope-circle scope-circle-outer"></div>
        <div class="scope-circle scope-circle-inner"></div>
    </div>
    
    <div id="hud">
        <div id="weapon-name">Pistolet</div>
        <div>Munitions: <span id="ammo">30</span> / <span id="reserve">90</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Ennemis: <span id="enemies">5</span></div>
        <div id="multiplayer-info">Mode: <span id="game-mode">Solo</span></div>
        <div id="match-timer" style="display: none;">Temps: <span id="timer">3:00</span></div>
        <div style="margin-top: 5px; color: #ffaa00; display: none;" id="kills-display">Kills: <span id="kills">0</span></div>
    </div>
    
    <div id="health-bar"><div id="health-fill"></div></div>
    
    <div id="instructions">
        <h2>FPS DEATH OF PAIN</h2>
        <p>ZQSD - Deplacement<br>Souris - Regarder<br>Clic gauche - Tirer<br>
        Clic droit - Viser<br>Espace - Sauter<br>R - Recharger<br>1,2,3 - Armes</p>
        <p><em>Cliquez pour jouer</em></p>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">Rejouer</button>
    </div>

    <div id="match-over">
        <h2 id="match-result">VICTOIRE!</h2>
        <p style="font-size: 24px;">
            <span id="your-kills-final">Tes kills: 0</span><br>
            <span id="opponent-kills-final">Adversaire: 0</span>
        </p>
        <button onclick="location.reload()">Rejouer</button>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let peer = null, conn = null, isMultiplayer = false;
        const otherPlayers = {};
        let myPlayerId = null, myUsername = 'Joueur';
        let matchTime = 180, matchTimer = null, opponentKills = 0, kills = 0;

        window.showModeSelect = function() {
            document.getElementById('mode-select').style.display = 'block';
            document.getElementById('hosting-info').style.display = 'none';
            document.getElementById('join-form').style.display = 'none';
        };

        window.showJoinForm = function() {
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('join-form').style.display = 'block';
        };

        window.playOffline = function() {
            myUsername = document.getElementById('username-input').value.trim() || 'Joueur';
            document.getElementById('connection-modal').classList.add('hidden');
            document.getElementById('game-mode').textContent = 'Solo';
            initGame();
        };

        window.startHosting = function() {
            myUsername = document.getElementById('username-input').value.trim() || 'Joueur';
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('hosting-info').style.display = 'block';
            document.getElementById('connection-status').textContent = 'Creation...';

            peer = new Peer({
                config: {
                    iceServers: [
                        { urls: 'stun:stun.relay.metered.ca:80' },
                        { urls: 'turn:a.relay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                        { urls: 'turn:a.relay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                }
            });

            peer.on('open', (id) => {
                myPlayerId = id;
                document.getElementById('my-peer-id').textContent = id;
                document.getElementById('connection-status').textContent = 'Pret !';
            });

            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(connection);
                setTimeout(() => {
                    isMultiplayer = true;
                    document.getElementById('connection-modal').classList.add('hidden');
                    document.getElementById('game-mode').textContent = 'Multi';
                    initGame();
                    sendData({ type: 'username', username: myUsername });
                }, 500);
            });

            peer.on('error', () => {
                document.getElementById('connection-status').textContent = 'Erreur serveur';
            });
        };

        window.connectToPeer = function() {
            myUsername = document.getElementById('username-input').value.trim() || 'Joueur';
            const remotePeerId = document.getElementById('peer-id-input').value.trim();
            if (!remotePeerId) return;

            document.getElementById('connection-status').textContent = 'Connexion...';

            peer = new Peer({
                config: {
                    iceServers: [
                        { urls: 'stun:stun.relay.metered.ca:80' },
                        { urls: 'turn:a.relay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                        { urls: 'turn:a.relay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                }
            });

            peer.on('open', () => {
                conn = peer.connect(remotePeerId, { reliable: true });
                setupConnection(conn);
                setTimeout(() => {
                    if (conn && conn.open) {
                        isMultiplayer = true;
                        document.getElementById('connection-modal').classList.add('hidden');
                        document.getElementById('game-mode').textContent = 'Multi';
                        initGame();
                        sendData({ type: 'username', username: myUsername });
                    }
                }, 2000);
            });
        };

        function setupConnection(connection) {
            connection.on('open', () => console.log('Connecte!'));
            connection.on('data', handleData);
            connection.on('close', () => location.reload());
        }

        function sendData(data) {
            if (conn && conn.open) conn.send(data);
        }

        function handleData(data) {
            if (!data) return;
            if (data.type === 'position') {
                if (otherPlayers['opponent']) {
                    otherPlayers['opponent'].targetPos = new THREE.Vector3(data.x, data.y, data.z);
                } else {
                    addOtherPlayer(data);
                }
            } else if (data.type === 'shoot') {
                createBullet(data);
            } else if (data.type === 'hit') {
                takeDamage(data.damage);
            } else if (data.type === 'killed') {
                kills++;
                document.getElementById('kills').textContent = kills;
                showKillMessage(false);
            } else if (data.type === 'matchEnd') {
                opponentKills = data.kills;
                if (matchTimer) endMatch();
            }
        }

        function addOtherPlayer(data) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 8, 3),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            body.position.y = 4;
            body.userData.hitbox = 'body';
            group.add(body);
            
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(3, 3, 3),
                new THREE.MeshStandardMaterial({ color: 0xcc0000 })
            );
            head.position.y = 10;
            head.userData.hitbox = 'head';
            group.add(head);

            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(data.username || 'Adversaire', 128, 38);
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(4, 1, 1);
            sprite.position.y = 13;
            group.add(sprite);
            
            group.position.set(data.x, data.y, data.z);
            group.targetPos = new THREE.Vector3(data.x, data.y, data.z);
            group.userData.isPlayer = true;
            scene.add(group);
            otherPlayers['opponent'] = group;
        }

        function createBullet(data) {
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff8800 })
            );
            bullet.position.set(data.x, data.y, data.z);
            bullet.velocity = new THREE.Vector3(data.vx, data.vy, data.vz);
            bullet.isEnemy = true;
            scene.add(bullet);
            bullets.push(bullet);
        }

        function respawnPlayer() {
            const spawnX = (Math.random() - 0.5) * 300;
            const spawnZ = (Math.random() - 0.5) * 300;
            controls.object.position.set(spawnX, PLAYER_HEIGHT, spawnZ);
            health = 100;
            document.getElementById('health-fill').style.width = '100%';
            weapons.forEach(w => { w.ammo = w.maxAmmo; w.reserve = w.maxAmmo * 3; });
            updateUI();
            
            const msg = document.createElement('div');
            msg.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#00ff00;font-size:48px;font-weight:bold;text-shadow:0 0 20px #00ff00;z-index:100';
            msg.textContent = 'RESPAWN';
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 2000);
        }

        function startMatchTimer() {
            document.getElementById('match-timer').style.display = 'block';
            document.getElementById('kills-display').style.display = 'block';
            
            matchTimer = setInterval(() => {
                matchTime--;
                const minutes = Math.floor(matchTime / 60);
                const seconds = matchTime % 60;
                document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                const timerEl = document.getElementById('match-timer');
                if (matchTime <= 30) {
                    timerEl.style.color = '#ff0000';
                    if (matchTime % 2 === 0) timerEl.style.transform = 'scale(1.1)';
                    else timerEl.style.transform = 'scale(1)';
                } else if (matchTime <= 60) {
                    timerEl.style.color = '#ffaa00';
                }
                
                if (matchTime <= 0) {
                    endMatch();
                }
            }, 1000);
        }

        function endMatch() {
            clearInterval(matchTimer);
            controls.unlock();
            const resultEl = document.getElementById('match-result');
            if (kills > opponentKills) {
                resultEl.textContent = 'üèÜ VICTOIRE! üèÜ';
                resultEl.style.color = '#ffd700';
            } else if (kills < opponentKills) {
                resultEl.textContent = 'üíÄ DEFAITE üíÄ';
                resultEl.style.color = '#ff0000';
            } else {
                resultEl.textContent = 'ü§ù EGALITE ü§ù';
                resultEl.style.color = '#00ff00';
            }
            document.getElementById('your-kills-final').textContent = `Tes kills: ${kills}`;
            document.getElementById('opponent-kills-final').textContent = `Adversaire: ${opponentKills}`;
            document.getElementById('match-over').style.display = 'block';
            sendData({ type: 'matchEnd', kills: kills });
        }

        function showKillMessage(isHeadshot) {
            const msg = document.createElement('div');
            const color = isHeadshot ? '#ff0000' : '#ffaa00';
            msg.style.cssText = `position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);color:${color};font-size:64px;font-weight:bold;text-shadow:0 0 20px ${color};z-index:100`;
            msg.textContent = isHeadshot ? 'üíÄ HEADSHOT!' : '‚ö° KILL!';
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 1500);
        }

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, prevTime = performance.now();
        const velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let score = 0, health = 100, isReloading = false, isAiming = false;
        const bullets = [], enemies = [], collidableObjects = [];
        let weapon, weaponRecoil = 0, currentWeaponIndex = 0, lastEmit = 0;

        const weapons = [
            { name: 'Pistolet', ammo: 30, maxAmmo: 30, reserve: 90, damage: 34, fireRate: 200, reloadTime: 1500, bulletSpeed: 500, spread: 0.01, bulletsPerShot: 1, color: 0x333333 },
            { name: 'Fusil', ammo: 8, maxAmmo: 8, reserve: 32, damage: 25, fireRate: 800, reloadTime: 2000, bulletSpeed: 400, spread: 0.1, bulletsPerShot: 8, color: 0x8B4513 },
            { name: 'Sniper', ammo: 5, maxAmmo: 5, reserve: 20, damage: 100, fireRate: 1200, reloadTime: 2500, bulletSpeed: 800, spread: 0, bulletsPerShot: 1, color: 0x1a1a1a }
        ];

        let lastShotTime = 0;
        const PLAYER_HEIGHT = 10, BASE_FOV = 75, AIM_FOV = 50;

        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(BASE_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000),
                new THREE.MeshStandardMaterial({ color: 0x228B22 })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            createWeapon();
            if (!isMultiplayer) createEnemies();
            updateUI();

            controls = new PointerLockControls(camera, document.body);
            document.getElementById('instructions').addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => document.getElementById('instructions').classList.add('hidden'));
            controls.addEventListener('unlock', () => document.getElementById('instructions').classList.remove('hidden'));
            scene.add(controls.object);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', e => e.preventDefault());

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            if (isMultiplayer) {
                setTimeout(() => startMatchTimer(), 3000);
            }
            
            animate();
        }

        function createWeapon() {
            weapon = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.2, 0.6),
                new THREE.MeshStandardMaterial({ color: weapons[0].color })
            );
            weapon.add(body);
            weapon.position.set(0.3, -0.3, -0.5);
            camera.add(weapon);
        }

        function createEnemies() {
            for (let i = 0; i < 5; i++) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 8, 3),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                body.position.y = 4;
                body.userData.hitbox = 'body';
                group.add(body);

                const head = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 3, 3),
                    new THREE.MeshStandardMaterial({ color: 0xcc0000 })
                );
                head.position.y = 10;
                head.userData.hitbox = 'head';
                group.add(head);

                group.position.set(Math.random() * 300 - 150, 0, Math.random() * -100 - 50);
                group.health = 100;
                group.velocity = new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2);
                scene.add(group);
                enemies.push(group);
            }
            document.getElementById('enemies').textContent = enemies.length;
        }

        function updateUI() {
            const w = weapons[currentWeaponIndex];
            document.getElementById('weapon-name').textContent = w.name;
            document.getElementById('ammo').textContent = w.ammo;
            document.getElementById('reserve').textContent = w.reserve;
        }

        function showDamage(dmg, pos, isHead) {
            const screenPos = pos.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;
            const el = document.createElement('div');
            el.className = 'damage-number' + (isHead ? ' headshot' : '');
            el.textContent = (isHead ? 'HEAD ' : '') + Math.round(dmg);
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function onKeyDown(e) {
            if (e.code === 'KeyW' || e.code === 'KeyZ') moveForward = true;
            if (e.code === 'KeyA' || e.code === 'KeyQ') moveLeft = true;
            if (e.code === 'KeyS') moveBackward = true;
            if (e.code === 'KeyD') moveRight = true;
            if (e.code === 'Space' && canJump) { velocity.y += 150; canJump = false; }
            if (e.code === 'KeyR') reload();
            if (e.code === 'Digit1') switchWeapon(0);
            if (e.code === 'Digit2') switchWeapon(1);
            if (e.code === 'Digit3') switchWeapon(2);
        }

        function onKeyUp(e) {
            if (e.code === 'KeyW' || e.code === 'KeyZ') moveForward = false;
            if (e.code === 'KeyA' || e.code === 'KeyQ') moveLeft = false;
            if (e.code === 'KeyS') moveBackward = false;
            if (e.code === 'KeyD') moveRight = false;
        }

        function onMouseDown(e) {
            if (e.button === 0 && controls.isLocked && !isReloading) shoot();
            if (e.button === 2 && controls.isLocked) startAiming();
        }

        function onMouseUp(e) {
            if (e.button === 2) stopAiming();
        }

        function startAiming() {
            isAiming = true;
            if (currentWeaponIndex === 2) {
                document.getElementById('sniper-scope').classList.add('active');
                document.getElementById('crosshair').style.display = 'none';
            } else {
                document.getElementById('crosshair').classList.add('aiming');
            }
            animateFOV(camera.fov, AIM_FOV);
        }

        function stopAiming() {
            isAiming = false;
            document.getElementById('sniper-scope').classList.remove('active');
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('crosshair').classList.remove('aiming');
            animateFOV(camera.fov, BASE_FOV);
        }

        function animateFOV(start, target) {
            const startTime = Date.now();
            function anim() {
                const progress = Math.min((Date.now() - startTime) / 200, 1);
                camera.fov = start + (target - start) * progress;
                camera.updateProjectionMatrix();
                if (progress < 1) requestAnimationFrame(anim);
            }
            anim();
        }

        function switchWeapon(idx) {
            if (idx === currentWeaponIndex || isReloading) return;
            currentWeaponIndex = idx;
            weapon.children[0].material.color.setHex(weapons[idx].color);
            updateUI();
        }

        function shoot() {
            const w = weapons[currentWeaponIndex];
            if (w.ammo <= 0 || Date.now() - lastShotTime < w.fireRate) return;
            lastShotTime = Date.now();
            w.ammo--;
            updateUI();
            weaponRecoil = 0.1;

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            for (let i = 0; i < w.bulletsPerShot; i++) {
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                bullet.position.copy(camera.position);
                const v = dir.clone();
                v.x += (Math.random()-0.5) * w.spread;
                v.y += (Math.random()-0.5) * w.spread;
                v.z += (Math.random()-0.5) * w.spread;
                v.normalize().multiplyScalar(w.bulletSpeed);
                bullet.velocity = v;
                bullet.damage = w.damage;
                bullet.weaponType = currentWeaponIndex;
                scene.add(bullet);
                bullets.push(bullet);
            }

            if (isMultiplayer) {
                sendData({
                    type: 'shoot',
                    x: camera.position.x, y: camera.position.y, z: camera.position.z,
                    vx: dir.x * w.bulletSpeed, vy: dir.y * w.bulletSpeed, vz: dir.z * w.bulletSpeed
                });
            }

            if (w.ammo === 0) reload();
        }

        function reload() {
            const w = weapons[currentWeaponIndex];
            if (isReloading || w.ammo >= w.maxAmmo || w.reserve <= 0) return;
            isReloading = true;
            setTimeout(() => {
                const add = Math.min(w.maxAmmo - w.ammo, w.reserve);
                w.ammo += add;
                w.reserve -= add;
                updateUI();
                isReloading = false;
            }, w.reloadTime);
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].position.add(bullets[i].velocity.clone().multiplyScalar(delta));
                
                let hit = false;
                const targets = isMultiplayer && otherPlayers['opponent'] ? [otherPlayers['opponent']] : enemies;
                
                if (!bullets[i].isEnemy) {
                    for (let j = targets.length - 1; j >= 0; j--) {
                        const target = targets[j];
                        if (bullets[i].position.distanceTo(target.position) < 5) {
                            for (let part of target.children) {
                                if (!part.geometry || part.type === 'Sprite') continue;
                                const partPos = new THREE.Vector3();
                                part.getWorldPosition(partPos);
                                if (bullets[i].position.distanceTo(partPos) < 3) {
                                    const isHead = part.userData.hitbox === 'head';
                                    let dmg = bullets[i].damage;
                                    if (isHead) dmg = bullets[i].weaponType === 2 ? 200 : dmg * 2;
                                    showDamage(dmg, partPos, isHead);
                                    
                                    if (isMultiplayer) {
                                        sendData({ type: 'hit', damage: dmg });
                                        if (dmg >= 100) {
                                            showKillMessage(isHead);
                                        }
                                    } else {
                                        target.health -= dmg;
                                        if (target.health <= 0) {
                                            scene.remove(target);
                                            enemies.splice(j, 1);
                                            score += isHead ? 200 : 100;
                                            document.getElementById('score').textContent = score;
                                            document.getElementById('enemies').textContent = enemies.length;
                                        }
                                    }
                                    hit = true;
                                    break;
                                }
                            }
                            if (hit) break;
                        }
                    }
                }
                
                if (hit || bullets[i].position.length() > 500) {
                    scene.remove(bullets[i]);
                    bullets.splice(i, 1);
                }
            }
        }

        function takeDamage(amount) {
            health -= amount;
            if (health < 0) health = 0;
            document.getElementById('health-fill').style.width = health + '%';

            if (health <= 0) {
                if (isMultiplayer) {
                    sendData({ type: 'killed', killerName: myUsername });
                    setTimeout(() => respawnPlayer(), 2000);
                } else {
                    controls.unlock();
                    document.getElementById('final-score').textContent = score;
                    document.getElementById('game-over').style.display = 'block';
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked && health > 0) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10 * delta;
                velocity.z -= velocity.z * 10 * delta;
                velocity.y -= 9.8 * 50 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.object.position.y += velocity.y * delta;

                if (controls.object.position.y < PLAYER_HEIGHT) {
                    velocity.y = 0;
                    controls.object.position.y = PLAYER_HEIGHT;
                    canJump = true;
                }

                if (isMultiplayer && Date.now() - lastEmit > 50) {
                    sendData({
                        type: 'position',
                        x: controls.object.position.x,
                        y: controls.object.position.y,
                        z: controls.object.position.z,
                        username: myUsername
                    });
                    lastEmit = Date.now();
                }

                if (otherPlayers['opponent']?.targetPos) {
                    otherPlayers['opponent'].position.lerp(otherPlayers['opponent'].targetPos, 0.2);
                }

                enemies.forEach(e => {
                    e.position.x += e.velocity.x * delta * 15;
                    e.position.z += e.velocity.z * delta * 15;
                    e.lookAt(controls.object.position);
                });

                updateBullets(delta);

                if (weaponRecoil > 0) {
                    weapon.position.z = -0.5 + weaponRecoil;
                    weaponRecoil -= delta * 2;
                } else {
                    weapon.position.z = -0.5;
                }

                prevTime = time;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
